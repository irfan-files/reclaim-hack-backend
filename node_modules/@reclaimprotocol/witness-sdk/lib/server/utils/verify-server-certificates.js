"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyServerCertificates = verifyServerCertificates;
const tls_1 = require("@reclaimprotocol/tls");
const parse_certificate_1 = require("@reclaimprotocol/tls/lib/utils/parse-certificate");
const utils_1 = require("../../utils");
const RECORD_LENGTH_BYTES = 3;
async function verifyServerCertificates(receipt, logger) {
    const handshakeMsgs = (0, utils_1.extractHandshakeFromTranscript)(receipt);
    let handshakeData = (0, tls_1.concatenateUint8Arrays)(handshakeMsgs.map(m => m.message));
    let packetData;
    const handshakeRawMessages = [];
    const certificates = [];
    let cipherSuite = undefined;
    let serverRandom = undefined;
    let clientRandom = undefined;
    let certVerified = false;
    while ((packetData = readPacket()) && !certVerified) {
        const { type, content } = packetData;
        switch (type) {
            case tls_1.SUPPORTED_RECORD_TYPE_MAP.CLIENT_HELLO:
                const clientHello = (0, tls_1.parseClientHello)(handshakeRawMessages[0]);
                clientRandom = clientHello.serverRandom;
                break;
            case tls_1.SUPPORTED_RECORD_TYPE_MAP.SERVER_HELLO:
                const serverHello = await (0, tls_1.parseServerHello)(content);
                cipherSuite = serverHello.cipherSuite;
                serverRandom = serverHello.serverRandom;
                break;
            case tls_1.SUPPORTED_RECORD_TYPE_MAP.CERTIFICATE:
                const parseResult = (0, tls_1.parseCertificates)(content, { version: receipt.tlsVersion });
                certificates.push(...parseResult.certificates);
                break;
            case tls_1.SUPPORTED_RECORD_TYPE_MAP.CERTIFICATE_VERIFY:
                const signature = (0, tls_1.parseServerCertificateVerify)(content);
                if (!(certificates === null || certificates === void 0 ? void 0 : certificates.length)) {
                    throw new Error('No provider certificates received');
                }
                const signatureData = await (0, tls_1.getSignatureDataTls13)(handshakeRawMessages.slice(0, -1), cipherSuite);
                await (0, tls_1.verifyCertificateSignature)({
                    ...signature,
                    publicKey: certificates[0].getPublicKey(),
                    signatureData,
                });
                await (0, parse_certificate_1.verifyCertificateChain)(certificates, receipt.hostname);
                logger.info({ host: receipt.hostname }, 'verified provider certificate chain');
                certVerified = true;
                break;
            case tls_1.SUPPORTED_RECORD_TYPE_MAP.SERVER_KEY_SHARE:
                if (!(certificates === null || certificates === void 0 ? void 0 : certificates.length)) {
                    throw new Error('No provider certificates received');
                }
                const keyShare = await (0, tls_1.processServerKeyShare)(content);
                const signatureData12 = await (0, tls_1.getSignatureDataTls12)({
                    clientRandom: clientRandom,
                    serverRandom: serverRandom,
                    curveType: keyShare.publicKeyType,
                    publicKey: keyShare.publicKey,
                });
                // verify signature
                await (0, tls_1.verifyCertificateSignature)({
                    signature: keyShare.signatureBytes,
                    algorithm: keyShare.signatureAlgorithm,
                    publicKey: certificates[0].getPublicKey(),
                    signatureData: signatureData12,
                });
                await (0, parse_certificate_1.verifyCertificateChain)(certificates, receipt.hostname);
                logger.info({ host: receipt.hostname }, 'verified provider certificate chain');
                certVerified = true;
                break;
        }
    }
    if (!certVerified) {
        throw new Error('No provider certificates received');
    }
    function readPacket() {
        if (!handshakeData.length) {
            return;
        }
        const type = handshakeData[0];
        const content = (0, tls_1.readWithLength)(handshakeData.slice(1), RECORD_LENGTH_BYTES);
        if (!content) {
            logger.warn('missing bytes from packet');
            return;
        }
        const totalLength = 1 + RECORD_LENGTH_BYTES + content.length;
        handshakeRawMessages.push(handshakeData.slice(0, totalLength));
        handshakeData = handshakeData.slice(totalLength);
        return { type, content };
    }
}
