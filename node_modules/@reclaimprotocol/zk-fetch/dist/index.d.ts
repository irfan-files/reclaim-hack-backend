declare enum HttpMethod {
    GET = "GET",
    POST = "POST"
}
declare enum LogType {
    VERIFICATION_STARTED = "VERIFICATION_STARTED",
    PROOF_GENERATED = "PROOF_GENERATED",
    ERROR = "ERROR",
    SUCCESS = "SUCCESS",
    FAILED = "FAILED"
}
type ProofRequestOptions = {
    log?: boolean;
    sessionId?: string;
};
type ApplicationId = string;
type ApplicationSecret = string;
type RequestUrl = string;
type ProviderId = string;
type NoReturn = void;
type SessionId = string;

interface Options {
    method: string;
    body?: string;
    headers?: {
        [key: string]: string;
    };
    geoLocation?: string;
}
interface secretOptions {
    body?: string;
    headers?: {
        [key: string]: string;
    };
    responseMatches?: {
        type: 'regex' | 'contains';
        value: string;
    }[];
    responseRedactions?: {
        regex?: string;
        jsonPath?: string;
        xPath?: string;
    }[];
}
interface Proof {
    identifier: string;
    claimData: ProviderClaimData;
    signatures: string[];
    witnesses: WitnessData[];
    extractedParameterValues: any;
}
interface WitnessData {
    id: string;
    url: string;
}
interface ProviderClaimData {
    provider: string;
    parameters: string;
    owner: string;
    timestampS: number;
    context: string;
    identifier: string;
    epoch: number;
}

declare class ReclaimClient {
    applicationId: string;
    applicationSecret: string;
    logs?: boolean;
    sessionId: string;
    constructor(applicationId: string, applicationSecret: string, logs?: boolean);
    zkFetch(url: string, options?: Options, secretOptions?: secretOptions, retries?: number, retryInterval?: number): Promise<Proof | undefined>;
}

export { type ApplicationId, type ApplicationSecret, HttpMethod, LogType, type NoReturn, type ProofRequestOptions, type ProviderId, ReclaimClient, type RequestUrl, type SessionId };
