"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateProof = generateProof;
exports.generateZkWitness = generateZkWitness;
exports.verifyProof = verifyProof;
const config_1 = require("./config");
const utils_1 = require("./utils");
const js_base64_1 = require("js-base64");
/**
 * Generate ZK proof for CHACHA20-CTR encryption.
 * Circuit proves that the ciphertext is a
 * valid encryption of the given plaintext.
 * The plaintext can be partially redacted.
 */
async function generateProof(opts) {
    const { algorithm, operator, logger } = opts;
    const { bitsPerWord, chunkSize, bitsToUint8Array } = config_1.CONFIG[algorithm];
    const witness = await generateZkWitness(opts);
    const { proof, publicSignals } = await operator.groth16Prove(witness, logger);
    const totalBits = chunkSize * bitsPerWord;
    return {
        algorithm,
        proofJson: typeof proof === 'string'
            ? proof
            : JSON.stringify(proof),
        plaintext: Array.isArray(publicSignals) ? //snarkJS
            bitsToUint8Array(publicSignals
                .slice(0, totalBits)
                .map((x) => +x)) :
            js_base64_1.Base64.toUint8Array(publicSignals) // gnark
    };
}
/**
 * Generate a ZK witness for the symmetric encryption circuit.
 * This witness can then be used to generate a ZK proof,
 * using the operator's groth16Prove function.
 */
async function generateZkWitness({ algorithm, privateInput: { key, }, publicInput: { ciphertext, iv, offset }, operator }) {
    const { keySizeBytes, ivSizeBytes, isLittleEndian, uint8ArrayToBits, } = config_1.CONFIG[algorithm];
    if (key.length !== keySizeBytes) {
        throw new Error(`key must be ${keySizeBytes} bytes`);
    }
    if (iv.length !== ivSizeBytes) {
        throw new Error(`iv must be ${ivSizeBytes} bytes`);
    }
    const startCounter = (0, utils_1.getCounterForChunk)(algorithm, offset);
    const ciphertextArray = padCiphertextToChunkSize(algorithm, ciphertext);
    const witness = await operator.generateWitness({
        key: uint8ArrayToBits(key),
        nonce: uint8ArrayToBits(iv),
        counter: serialiseCounter(),
        in: uint8ArrayToBits(ciphertextArray),
    });
    return witness;
    function serialiseCounter() {
        const counterArr = new Uint8Array(4);
        const counterView = new DataView(counterArr.buffer);
        counterView.setUint32(0, startCounter, isLittleEndian);
        const counterBits = uint8ArrayToBits(counterArr)
            .flat();
        return counterBits;
    }
}
/**
 * Verify a ZK proof for CHACHA20-CTR encryption.
 *
 * @param proofs JSON proof generated by "generateProof"
 * @param publicInput
 * @param zkey
 */
async function verifyProof({ proof: { algorithm, plaintext, proofJson }, publicInput: { ciphertext, iv, offset }, operator, logger }) {
    const { uint8ArrayToBits, isLittleEndian, startCounter } = config_1.CONFIG[algorithm];
    const ciphertextArray = padCiphertextToChunkSize(algorithm, ciphertext);
    if (ciphertextArray.length !== plaintext.length) {
        throw new Error(`ciphertext and plaintext must be the same length`);
    }
    // serialise to array of numbers for the ZK circuit
    const pubInputs = [
        ...uint8ArrayToBits(plaintext),
        ...uint8ArrayToBits(iv),
        ...serialiseCounter(),
        ...uint8ArrayToBits(ciphertextArray),
    ].flat();
    const verified = await operator.groth16Verify(pubInputs, JSON.parse(proofJson));
    if (!verified) {
        throw new Error('invalid proof');
    }
    function serialiseCounter() {
        const counterArr = new Uint8Array(4);
        const counterView = new DataView(counterArr.buffer);
        counterView.setUint32(0, offset + startCounter, isLittleEndian);
        return uint8ArrayToBits(counterArr)
            .flat();
    }
}
function padCiphertextToChunkSize(alg, ciphertext) {
    const { chunkSize, bitsPerWord, } = config_1.CONFIG[alg];
    const expectedSizeBytes = (chunkSize * bitsPerWord) / 8;
    if (ciphertext.length > expectedSizeBytes) {
        throw new Error(`ciphertext must be <= ${expectedSizeBytes}b`);
    }
    if (ciphertext.length < expectedSizeBytes) {
        const arr = new Uint8Array(expectedSizeBytes).fill(0);
        arr.set(ciphertext);
        ciphertext = arr;
    }
    return ciphertext;
}
